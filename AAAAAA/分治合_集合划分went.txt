/*
?	问题描述：n个元素的集合{1,2,..., n }可以划分为若干个非空子集。例如，当n = 4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下：{{1}，{2}，{3}，{4}}， {{1，2}，{3}，{4}}，{{1，3}，{2}，{4}}， {{1，4}，{2}，{3}}，{2，3}，{1}，{4}}， {{2，4}，{1}，{3}}，{{3，4}，{1}，{2}}， {{1，2}，{3，4}}，{{1，3}，{2，4}}， {{1，4}，{2，3}}，{{1，2，3}，{4}}， {{1，2，4}，{3}}，{{1，3，4}，{2}}， {{2，3，4}，{1}}， {{1，2，3，4}}
给定正整数n，计算出n 个元素的集合{1,2,..., n }可以划分为多少个不同的非空子集。
输入：多组测试数据。每组有且仅有一行为一个正整数n( 0 < n < 18 )。
输出：输出n个元素集合的非空子集数。
输入样例     5
输出样例     52

给定正整数n，计算出n个元素的集合{1,2,?, n }可以划分为多少个不同的非空子集。  
 所求的是Bell 数 满足递推公式 B(n) =          
所以这道题实际求第二类Stirling数  S(n,m)
解决思想：
1.  若 m == 1    则S(n,m) = 1;    ( n >= 0 )
2.  若 m == 0    则S(n,m) = 0;    ( n >= 1  )
3.  若 n == m   则S(n,m) = 1;   

4 . 若非以上3中情况 则：
     (1)  已知前S（n-1,m）的解决方案 ， 第n个数可以向分出来的m个非空子集中的每一个任意添加进去  共有m*S(n-1,m)方法
     (2) 前n-1个数已经划分成 m-1  剩余第n个数单独作为一个非空子集添加进去  共有S(n-1,m-1)种方法

*/

#include<iostream>

using namespace std;

int stiring(int n, int m)
{
	if (m == 0 || m > n)
		return 0;
	if (m == 1 || m == n)
		return 1;
	return m*stiring(n - 1, m) + stiring(n - 1, m-1);

}
int main()
{
	int n;
	while (cin >> n && n != -1)
	{
		int rnt = 0;
		for (int i = 1; i <= n; i++)
			rnt += stiring(n, i);
		cout << rnt << endl;
	}
	return 0;
}