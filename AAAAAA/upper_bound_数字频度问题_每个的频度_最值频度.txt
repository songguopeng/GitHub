#include<iostream>
#include<algorithm>
#include<vector>

#include<iterator>
using namespace std;

//时间快
int main()
{
	int A[] = { 1,3,2,3,4,3,6,3 };
	int nSize = sizeof(A) / sizeof(int);
	sort(A, A + nSize);
	int *first = A;
	int *last = NULL,*last1=NULL;
	int find_value = A[0];
	do
	{
		last = upper_bound(first, A + nSize, find_value);//按照从小到大排序， 第一个>find_value的位置;
		last1 = lower_bound(A, A + nSize, find_value);//按照从小到大排序，第一个<=find_value的位置；

		cout << "find_value=" << find_value << "\t频度" << (float)(last - first)  << endl;

		cout << "Lower_find" << find_value << "\t" << (last1 - A) << endl;
		first = last;
		if (first != A + nSize)
			find_value = * first;
	} while (first!=A+nSize);
	system("pause");
	return 0;
}
//时间慢，求出每个值的频度；
int main()
{
	int A[] = { 1,3,2,3,4,3,6,3 };
	int nSize = sizeof(A) / sizeof(int);
	sort(A, A + nSize);
	vector<int> tmp;
	unique_copy(A, A + nSize,back_inserter(tmp));
	for (int i = 0; i < tmp.size(); i++)
	{
		int n = count(A, A + nSize, tmp[i]);
		cout << "find_value=" << tmp[i] << "\t频度:" << (float)n  << endl;

	}
	system("pause");
	return 0;
}
//求元素频度超过50%是否存在 nth_element

int main()
{
	int A[] = { 1,3,2,3,4,3,6,3,3 };
	int nSize = sizeof(A) / sizeof(int);
	nth_element(A, A + nSize / 2, A + nSize);//nth_element()方法的使用 通过调用nth_element(start, start+n, end) 方法可以使第n大元素处于第n位置（从0开始,其位置是下标为 n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的

	int find_value = *(A + nSize / 2);
	int nCount = count(A, A + nSize, find_value);
	float ratio = (float)nCount / nSize;
	if (ratio > 0.5f)
		cout << "多数元素是：" << find_value << "\t频度:" << ratio*nSize << endl;
	else
		cout << "没有多数元素" << endl;
	system("pause");
	return 0;
}